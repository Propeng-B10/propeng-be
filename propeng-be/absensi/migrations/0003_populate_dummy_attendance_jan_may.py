# Generated by Django X.Y on YYYY-MM-DD HH:MM
# (Keep the original generated timestamp)

from django.db import migrations
from django.utils import timezone
from datetime import date, timedelta
import random
import string # Needed for potential kode generation if you populate that too,
              # though the main goal is listSiswa
import json   # Useful if listSiswa is complex JSON strings

# Define the function that will populate the data
def create_dummy_attendance(apps, schema_editor):
    # Get the historical models (crucial for migrations)
    # Make sure the app labels and model names match exactly
    Kelas = apps.get_model('kelas', 'Kelas')
    AbsensiHarian = apps.get_model('absensi', 'AbsensiHarian')
    Student = apps.get_model('user', 'Student') # Student model is in the 'user' app

    # --- Configuration ---
    # Define the name of the class you want to populate attendance for
    # IMPORTANT: Replace 'Nama Kelas Target' with the actual name of the class.
    # You can add more names to this list if you want to populate multiple classes.
    target_kelas_names = ['Kelas ABIL'] # Use a list for potentially multiple classes

    # Define the date range
    year = timezone.now().year # Use current year
    start_date = date(year, 1, 1)
    end_date = date(year, 6, 30) # Up to May 15th of the current year

    # Define attendance statuses and their weights for random generation
    # Adjust weights as needed for desired distribution
    attendance_statuses = ['Hadir', 'Sakit', 'Izin', 'Alfa']
    weights = [0.80, 0.05, 0.05, 0.10] # Example weights: 80% Hadir, 5% Sakit, 5% Izin, 10% Alfa

    # --- Data Generation Logic ---
    for class_name in target_kelas_names:
        try:
            # Find the target class (case-insensitive search)
            kelas_obj = Kelas.objects.filter(
                namaKelas__iexact=class_name # Use iexact for case-insensitive exact match
            ).first()

            if not kelas_obj:
                print(f"Skipping dummy attendance: Class '{class_name}' not found.")
                continue # Go to the next class if the current one isn't found

            students_in_class = kelas_obj.siswa.all()

            if not students_in_class.exists():
                 print(f"Skipping dummy attendance: No students found in class '{kelas_obj.namaKelas}'.")
                 continue

            print(f"Populating attendance for class '{kelas_obj.namaKelas}' from {start_date} to {end_date}")

            current_date = start_date
            while current_date <= end_date:
                # Skip weekends (Monday=0, Sunday=6)
                if current_date.weekday() >= 5: # 5 is Saturday, 6 is Sunday
                    current_date += timedelta(days=1)
                    continue

                # Check if attendance record already exists for this class and date
                existing_absensi = AbsensiHarian.objects.filter(
                    kelas=kelas_obj,
                    date=current_date
                ).first()

                if existing_absensi:
                    # Skip if a record for this date already exists for this class
                    # print(f"Absensi for {current_date} in {kelas_obj.namaKelas} already exists. Skipping.")
                    pass # Do nothing, proceed to next date
                else:
                    # Create a new AbsensiHarian record
                    # The AbsensiHarian save() method should initialize listSiswa
                    # with students and default status ('Alfa').
                    # Provide a valid choice for tipeAbsensi from your model choices.
                    absensi_record = AbsensiHarian(
                        kelas=kelas_obj,
                        date=current_date,
                        tipeAbsensi='Absen' # Choose a valid default like 'Absen'
                    )
                    absensi_record.save() # This triggers the listSiswa initialization in the model's save()

                    # Now update listSiswa with random statuses.
                    # We need to reload the absensi_record potentially, or work directly on absensi_record.listSiswa
                    # The save() method populated it, let's modify it.
                    updated_list_siswa = {}
                    for student in students_in_class:
                         # Ensure student_id is a string for JSONField keys
                        student_id_str = str(student.user_id)

                        random_status = random.choices(attendance_statuses, weights=weights, k=1)[0]

                        # Ensure the data format matches what your views expect/create
                        # Based on your AbsensiHarian save() and update_absen(), the format
                        # seems to evolve from simple status to {"name": ..., "status": ..., "id": ...}
                        # Let's generate the richer format directly.
                        updated_list_siswa[student_id_str] = {
                            "name": student.name,
                            "status": random_status,
                            "id": student.user_id # Include the ID in the structure
                        }


                    # Assign the updated listSiswa and save again
                    absensi_record.listSiswa = updated_list_siswa
                    absensi_record.save()

                    # print(f"Created and populated absensi record for {current_date} in {kelas_obj.namaKelas}")


                # Move to the next day
                current_date += timedelta(days=1)

            print(f"Finished populating dummy attendance for class '{kelas_obj.namaKelas}'.")

        except Exception as e:
            print(f"An error occurred during dummy attendance population for class '{class_name}': {e}")
            import traceback
            traceback.print_exc()
            # Continue to the next class if one fails, or uncomment raise e if you want strict failure
            # raise e


class Migration(migrations.Migration):

    # !!! IMPORTANT !!!
    # Adjust these dependencies to match the *actual* names of the migrations
    # in your respective apps' migrations folders right before this migration.
    dependencies = [
        ('absensi', '0002_initial'), # Change '0002_initial' if the previous absensi migration is named differently
        ('kelas', '0001_initial'), # Change '0001_initial' to the latest schema migration name in your kelas/migrations folder
        ('user', '0001_initial'), # Change '0001_initial' to the latest schema migration name in your user/migrations folder
        # You don't necessarily need a dependency on 'tahunajaran' here
        # because Angkatan is accessed via Student/Teacher models, which are
        # already dependencies through the 'user' app.
    ]

    operations = [
        # Add the RunPython operation to execute the function
        migrations.RunPython(create_dummy_attendance),
        # If you need to run a reverse operation (e.g., delete the data),
        # you could define a reverse_create_dummy_attendance function and add it like:
        # migrations.RunPython(create_dummy_attendance, reverse_code=reverse_create_dummy_attendance),
        # But for simple dummy data population, reverse_code is often not needed.
    ]
